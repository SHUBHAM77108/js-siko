<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // This is function
        function greeting(){
            console.log('hello');
        }
        greeting(); // this is called the Call Function and (running function)

        // Function are also values we can save inside a variable like number,string and boolean values;

        const function1 = function greeting(){
            console.log('hello');
        };

        console.log(function1); // return hole function
        console.log(typeof function1); // function
        function1(); // we can call function this wall by using variable name and this will be excute ha function // hello

        // In upper function we use the variable name to call the function not using the function name (greeting) to call
        // that way we not use of function name than we can remove them 

        const function2 = function() {
            console.log('hello');
        } // this called Anonymous Function which means a function wihout a name 

//*** advantages of simple function creating is we  one it's easier to read and number two it gives us a feature called hoisting which means we can call this function greeting brackets before we create

        // using hoisting we don't have to worry about what order we write this code

        // hoisting doesn't work when we create our function and save it in a variable

        const object1 = {
            num: 2,
            // we don't need to give function name because we use call function using method name 
            // Anonymous Function
            // fun: function greeting() {
            fun: function() {
                console.log('hello3');
            }
        };
        object1.fun(); // we can call function save inside objects method.

        function display(param) {
            console.log(param);
        }

        display(2); // this way we can also pass a function into a function
        
//***
        function run(param) {
            // we can use param just like variable and because param contains function we can actually call it 
            param(); // hello4 // this called (passing a function into another function)
        }

        // So this take function and save into param
        run(function() {
            console.log('hello4');
        })
        //the function we're passing inside run we're are called a (callback function) or a (callback)

//*** so setTimeout is build in function in JS
        // now setTimeout is take two parameters:
        // 1) A function we want to run in the future
        // 2) How long to wait before running this function (take a number in millisecond) 1000 millisecond = 1 second;
        setTimeout(function() {
            console.log('timeout');
            console.log('timeout2');// that we normally write will be synchronous code line by line
        }, 3000);// so setTimeout will wait for 3 sec
        //so that is setTimeout we give it a function and it will call this function after a certain amount of time

        //*** so now we're going to learn called Asynchronous code
        console.log('next line');//this will run first before setTimeout function this called asynchronous code

        //asynchronous code:
        // means won't wait for a line to finish before going to the next line (as usual the only time that code becomes asynchronous is when we use certain feature of JS like setTimeout)

        // synchronous code:
        // means will wait for one line to finish before going to the next line // so all the code we're written in this JS learning so far has been synchronous code (code run line by line)

        // so setTimeout is only part that is asynchronous now the advantages of set timeout being asynchronous is that it doesn't block our code for 3 second waiting for this timer to finish


//****so setTimeout is build in function in JS
        // now setTimeout is take two parameters:
        // 1) A function we want to run in the future
        // 2) How long to wait before running this function (take a number in millisecond) 1000 millisecond = 1 second;
        setInterval(function() {
            console.log('interval');
        }, 3000);// setInterval will run this function every 3 sec
        // setInterval is also asynchronous

        console.log('next line 2');


//****forEach() array Method:---------
    //Works only on arrays
 // forEach() JavaScript ka ek powerful array method hai jo array ke har element ke liye ek specific function ko execute karta hai. Yeh method array ke har element ko ek baar visit karta hai aur uske liye provided callback function ko call karta hai.

    // Syntax:
    //array.forEach(function(element, index, array) {
    // Code to be executed for each element
    //});

    // array: Yeh woh array hai jisme forEach method apply ho raha hai.
    //function(element, index, array): Yeh callback function hai jo array ke har element ke liye call hota hai.
    //element: Array ka current element jo us waqt process ho raha hai.
    //index (optional): Yeh us current element ka index hota hai.
    //array (optional): Yeh pura array hota hai jisme se element aaya hai.

    //****************************************
    // Example 1: Simple forEach() without index

    const fruits = ['apple', 'banana', 'mango'];

    fruits.forEach(function(fruit) {
    console.log(fruit);
    }); // apple banana mango

    //****************************************
    // Example 2: Using index in forEach()

    fruits.forEach(function(fruit, index) {
    console.log(`${index}: ${fruit}`);
    });// 0: apple 1: banana 2: mango

    //****************************************
    // Example 3: Using all 3 parameters (element, index, and array)

    fruits.forEach(function(fruit, index, array) {
    console.log(`Index ${index}: ${fruit} in array [${array}]`);
    });
    //Index 0: apple in array [apple,banana,mango]
    //Index 1: banana in array [apple,banana,mango]
    //Index 2: mango in array [apple,banana,mango]

    //***** Important points:

    //1 Modifying the array: forEach() me directly array modify nahi karna chahiye. Agar aapko array me changes karne hain, to map(), filter() jaise methods use karna better hota hai.

    //2 Breaking out of forEach(): forEach() ko middle me break nahi kar sakte jaise aap for loop me break statement use karte ho. Agar kisi specific condition pe loop ko rokna hai to forEach() sahi choice nahi hai, uske liye for ya for...of loops better hai.

    //***** Common Use Cases:

    // Jab aapko array ke elements ko process karna ho bina koi new array return kiye.
    // Jab aapko array ke elements ke sath koi side effect perform karna ho (like printing, updating DOM, etc.).

    //***** Conclusion:

    // forEach() simple aur convenient hota hai jab aapko array ke har element ke upar koi operation perform karna ho bina result ko return kiye.
    // forEach() mainly use hota hai jab aapko bas array ko traverse karna ho ya operations perform karne ho, aur array ka output modify nahi karna ho.

//***************************************************
//***** filter()---------------
    // filter() array ke har element pe ek condition check karta hai aur jo elements condition satisfy karte hain, unhe return karta hai. Is method ka result ek new array hota hai jo sirf un elements se bana hota hai jo condition ko meet karte hain.

    // let filteredArray = array.filter(function(element, index, array) {
    //     // return condition (true/false)
    // });

    // element: current element jo process ho raha hai.
    // index (optional): us element ka index.
    // array (optional): pura array jisme se element aaya hai.
    //return: true agar element ko filter karna hai, false agar nahi karna.

    // Example 1: Filtering even numbers

    const numbers = [1, 2, 3, 4, 5, 6];

    const evenNumbers = numbers.filter(function(number) {
        return number % 2 === 0;
    });

    console.log(evenNumbers); // Output: [2, 4, 6]

    // Example 2: Filtering strings with more than 3 characters

    // const words = ['sun', 'moon', 'earth', 'star'];

    // const longWords = words.filter(function(word) {
    //     return word.length > 3;
    // });

    // console.log(longWords); // Output: ['moon', 'earth', 'star']

//**************************************************************
    //**** map()---------
    // map() array ke har element pe ek function apply karta hai aur har element ka modified version return karta hai. Iska result ek new array hota hai jisme original array ke har element ka transformed version hota hai.

    // Syntax:
    // javascript
    // let newArray = array.map(function(element, index, array) {
    //     // return new value
    // });

    // element: current element jo process ho raha hai.
    // index (optional): us element ka index.
    // array (optional): pura array jisme se element aaya hai.
    // return: naya value jo array ke corresponding index pe aayega.

    // Example 1: Squaring each number
    // const numbers = [1, 2, 3, 4];

    // const squaredNumbers = numbers.map(function(number) {
    //     return number * number;
    // });

    // console.log(squaredNumbers); // Output: [1, 4, 9, 16]

    // Example 2: Uppercasing strings
    // const words = ['apple', 'banana', 'cherry'];

    // const upperCaseWords = words.map(function(word) {
    //     return word.toUpperCase();
    // });

    // console.log(upperCaseWords); // Output: ['APPLE', 'BANANA', 'CHERRY']

    //*******************************************************
    //**** reduce()-------
    // reduce() array ke elements ko ek single value me reduce karta hai. Yeh method accumulator aur current element ko use karke array ke har element pe operation perform karta hai aur ek final result return karta hai.

    // let result = array.reduce(function(accumulator, element, index, array) {
    // // return new accumulator value
    // }, initialValue);

    //> accumulator: yeh wo value hai jo har iteration ke baad update hoti hai (final result ka part).
    //> element: current element jo process ho raha hai.
    //> index (optional): us element ka index.
    //> array (optional): pura array.
    //> initialValue: accumulator ki starting value (optional but recommended).

    // Example 1: Sum of all numbers

    const numbersreduce = [1, 2, 3, 4];

    const sum = numbersreduce.reduce(function(accumulator, number) {
        return accumulator + number;
    }, 0);

    console.log(sum); // Output: 10

    // Example 2: Finding maximum value

    const numbersreduceTwo = [3, 5, 2, 8, 1];

    const max = numbersreduceTwo.reduce(function(accumulator, number) {
        return number > accumulator ? number : accumulator;
    }, numbersreduceTwo[0]);

    console.log(max); // Output: 8

    //***** Use Cases and Differences: ---------

    // 1. forEach():--
    // Use Case:--
    // Jab aapko array ke har element pe ek operation perform karna ho bina koi new array banaye. Iska typical use logging, modifying external variables ya DOM elements ko update karna hota hai.

    // Important Points:--
    // Return value: Kuch return nahi karta.
    // Side Effects: Mostly side effects create karne ke liye use hota hai (jaise console log karna ya DOM update karna).
    // Not Chainable: Isko aap chaining ke liye use nahi kar sakte kyunki ye kuch return nahi karta.

    // 2. map():--
    // Use Case:
    // Jab aapko array ke har element ko modify karke naya array banana ho. Jaise kisi array ke sab elements ko double karna ya koi nayi property add karna.

    // Important Points:--
    // Return value: New array return karta hai jo modified values contain karta hai.
    // Immutable: Original array ko modify nahi karta, balki ek new array banata hai.
    // Chainable: Isko aap chaining ke liye use kar sakte ho kyunki yeh new array return karta hai.

    // 3. filter():--
    // Use Case:
    // Jab aapko array se kuch specific elements ko filter karke naya array banane ki zarurat ho. Jaise aapko even numbers ya certain conditions ko satisfy karne wale elements chahiye ho.

    // Important Points:--
    // Return value: Naya array return karta hai jo sirf un elements ko contain karta hai jo condition satisfy karte hain.
    // Immutable: Original array ko modify nahi karta, ek new array return karta hai.
    // Chainable: Aap isko chaining ke liye use kar sakte ho.

    // 4. reduce():--
    // Use Case:
    // Jab aapko array ke elements ko combine ya aggregate karke ek single value nikalni ho. Isko aap total sum ya product, ya array ke elements ko ek string mein convert karne ke liye use kar sakte ho.

    // Important Points:--
    // Return value: Single value return karta hai jo array ke saare elements ko aggregate karta hai.
    // Initial Value: Isme aap initial value provide kar sakte ho jo aggregation ka base hota hai.
    // Chainable: Chaining ke liye iska use nahi hota, kyunki ye ek single value return karta hai, array nahi.



    </script>
</body>
</html>